# DSP_audio_benchmark
音声ファイル取得からMFCC(メル周波数ケプストラム係数)への変換までのベンチマーク

## 候補
* Python
* Rust
* Swift

## それぞれの良い点と懸念点

観点
* 速度
* 作りやすさ
  * エコシステム
  * 学習コスト
  * 保守性


言語   | 良い点                                      | 懸念点
---    | ---                                         | ---
Python | 慣れてる、一番簡単、資料多い                | 速度は微妙かも(NumPyでも)、 保守性が微妙
Rust   | 最速、安全、おもしろい                      | GUIが微妙らしい、むずかしい、慣れてない
Swift  | 慣れてる、楽しい、Apple限定で作るならこれ   | Apple限定(vDSPフレームワーク)

## 考察

Rustはハードルが高いけど本気でやるならベストな選択。
SwiftはApple限定でなければ本当に最高。
Pythonは一番簡単だけど遅いかも。

## 決め方

取り組むべき順に並び替えた。

言語   | 決め方
---    | ---
Python | 正直これが一番楽。ベンチマークを取ってみて他のとそこまで差が出ないならこれにする
Rust   | 最速値取得用。やってみて案外行けそうと思ったらこれにする
===    | === 壁 === 以下余裕があればやってみる
Swift  | Apple限定なら最有力候補なのでやってみる。速度が思ったより出ないなら諦める。

## ベンチマークの取り方

バッファにとっておいた音声データをMFCCに変換するまでの速度を計測する。計測するプログラムの作りやすさも感じておく。

### 条件

```
MacBook Pro (13-inch, 2018)
OS: macOS Big Sur
CPU: Intel Core i5-8259U @ 2.3 GHz (4 cores)
DRAM: 16GB 2,133MHz LPDDR3
GPU: Intel Iris Plus Graphics 655
```

言語ごとにベンチマーク測定プログラムを作成する。

ベンチマーク測定は複数回行い、平均と標準偏差を求める。

### MFCCを求める

MFCCを求めるための条件
* サンプリング周波数=16kHz
* 次元数=12
* FFTの要素数=1024(16kHzにおいては64ms)
* STFTのホップサイズ=256
* メルフィルタバンクの次元数=20
* DCTの定義=DCT-Ⅱ

1. ストリーミングのように、1分間のwavファイルを128ミリ秒のフレームに分けてバッファにとっておき、そのあと計測をスタートしてそれぞれMFCCを求める。
    * マイク入力を想定するのでwhile文で実装する。

なお、作りやすさも見たいのでパッケージ化を試みる。パッケージ名は`audio.feature`としておく。
